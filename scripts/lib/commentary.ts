/**
 * Commentary Generation Library
 *
 * Generates multi-dimensional art commentary using LLM (Claude/Gemini)
 * with RAG-enhanced accuracy and file-based storage.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Types
// ============================================================================

export interface Artwork {
  id: number;
  title: string;
  artist: string;
  year: number | string;
  medium: string;
  dimensions?: string;
  location?: string;
  category: 'painting' | 'sculpture' | 'architecture';
  wikiUrl?: string;
  museumUrl?: string;
}

export interface CommentaryMetadata {
  artworkId: number;
  generatedAt: string;
  modelName: string;
  promptVersion: string;
  humanEdited: boolean;
  sources: string[];
}

export interface Commentary {
  metadata: CommentaryMetadata;
  content: string; // Full markdown content
}

// ============================================================================
// Configuration
// ============================================================================

const PROMPT_TEMPLATE_PATH = path.join(__dirname, '../prompts/commentary-generation-v1.md');
const COMMENTARY_BASE_DIR = path.join(__dirname, '../../data/commentary');
const PROMPT_VERSION = 'v1.0';

// ============================================================================
// RAG: Fetch Authoritative Sources
// ============================================================================

/**
 * Fetch Wikipedia summary for an artwork
 */
async function fetchWikipediaSummary(artworkTitle: string, artist: string): Promise<string> {
  // TODO: Implement Wikipedia API fetch
  // Example: https://en.wikipedia.org/api/rest_v1/page/summary/{title}
  console.log(`[RAG] Fetching Wikipedia for: ${artworkTitle}`);
  return 'Wikipedia summary placeholder';
}

/**
 * Fetch museum description if available
 */
async function fetchMuseumDescription(museumUrl?: string): Promise<string> {
  if (!museumUrl) return 'No museum URL provided';

  // TODO: Implement museum page scraping or API fetch
  console.log(`[RAG] Fetching museum data from: ${museumUrl}`);
  return 'Museum description placeholder';
}

/**
 * Build context bundle for LLM
 */
async function buildContext(artwork: Artwork): Promise<string> {
  const wikiSummary = await fetchWikipediaSummary(artwork.title, artwork.artist);
  const museumDesc = await fetchMuseumDescription(artwork.museumUrl);

  return `
**Artwork Metadata:**
- Title: ${artwork.title}
- Artist: ${artwork.artist}
- Year: ${artwork.year}
- Medium: ${artwork.medium}
- Dimensions: ${artwork.dimensions || 'Unknown'}
- Current Location: ${artwork.location || 'Unknown'}

**Wikipedia Summary:**
${wikiSummary}

**Museum Description:**
${museumDesc}
`.trim();
}

// ============================================================================
// LLM Integration
// ============================================================================

/**
 * Generate commentary using LLM (Claude/Gemini)
 */
async function callLLM(prompt: string, context: string): Promise<string> {
  // TODO: Implement actual LLM API call
  // Options:
  // 1. Anthropic Claude API (claude-3-5-sonnet-20241022)
  // 2. Google Gemini API (gemini-1.5-pro)

  console.log('[LLM] Generating commentary...');
  console.log('[LLM] Prompt length:', prompt.length);
  console.log('[LLM] Context length:', context.length);

  // Placeholder: actual implementation would call API
  const fullPrompt = `${prompt}\n\n---\n\n${context}`;

  // Example response structure
  return `
# The Starry Night (1889)
**Artist:** Vincent van Gogh
**Medium:** Oil on canvas
**Dimensions:** 73.7 cm × 92.1 cm
**Location:** Museum of Modern Art, New York

---

## Art & Technique
[Generated content would go here...]

**Key observation:** The cypress tree in the foreground, painted with urgent, flame-like strokes, acts as a dark anchor connecting earth to sky—a motif Van Gogh associated with death and eternity.

[... rest of commentary ...]

## Sources
- MoMA Collection: https://www.moma.org/collection/works/79802
- Van Gogh Letters: http://vangoghletters.org/vg/letters/let779.html
- Generated by Claude Sonnet 4.5 on ${new Date().toISOString().split('T')[0]}
`.trim();
}

// ============================================================================
// File Storage
// ============================================================================

/**
 * Get file path for artwork commentary
 */
function getCommentaryPath(artwork: Artwork): string {
  const slug = artwork.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const filename = `${String(artwork.id).padStart(4, '0')}-${slug}.md`;
  return path.join(COMMENTARY_BASE_DIR, artwork.category, filename);
}

/**
 * Write commentary to markdown file
 */
async function writeCommentaryFile(
  artwork: Artwork,
  content: string,
  metadata: CommentaryMetadata
): Promise<string> {
  const filePath = getCommentaryPath(artwork);

  // Ensure directory exists
  await fs.mkdir(path.dirname(filePath), { recursive: true });

  // Append metadata footer
  const metadataFooter = `

---

_Generated: ${metadata.generatedAt}_
_Model: ${metadata.modelName}_
_Prompt Version: ${metadata.promptVersion}_
_Human Edited: ${metadata.humanEdited ? 'Yes' : 'No'}_
`;

  const fullContent = content + metadataFooter;

  await fs.writeFile(filePath, fullContent, 'utf-8');
  console.log(`[FILE] Written to: ${filePath}`);

  return filePath;
}

/**
 * Read existing commentary if available
 */
async function readCommentaryFile(artwork: Artwork): Promise<string | null> {
  const filePath = getCommentaryPath(artwork);

  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      return null; // File doesn't exist
    }
    throw err;
  }
}

// ============================================================================
// Main Generation Function
// ============================================================================

/**
 * Generate commentary for an artwork
 *
 * @param artwork - Artwork metadata
 * @param force - Regenerate even if file exists
 * @returns Path to generated commentary file
 */
export async function generateCommentary(
  artwork: Artwork,
  force: boolean = false
): Promise<string> {
  console.log(`\n[GENERATE] ${artwork.title} by ${artwork.artist}`);

  // Check if commentary already exists
  const existing = await readCommentaryFile(artwork);
  if (existing && !force) {
    console.log('[SKIP] Commentary already exists. Use --force to regenerate.');
    return getCommentaryPath(artwork);
  }

  // Load prompt template
  const promptTemplate = await fs.readFile(PROMPT_TEMPLATE_PATH, 'utf-8');

  // Build context from authoritative sources
  const context = await buildContext(artwork);

  // Generate commentary via LLM
  const generatedContent = await callLLM(promptTemplate, context);

  // Prepare metadata
  const metadata: CommentaryMetadata = {
    artworkId: artwork.id,
    generatedAt: new Date().toISOString().split('T')[0],
    modelName: 'Claude Sonnet 4.5', // TODO: Make configurable
    promptVersion: PROMPT_VERSION,
    humanEdited: false,
    sources: [] // TODO: Extract from generated content
  };

  // Write to file
  const filePath = await writeCommentaryFile(artwork, generatedContent, metadata);

  return filePath;
}

/**
 * Batch generate commentaries for multiple artworks
 */
export async function batchGenerateCommentaries(
  artworks: Artwork[],
  options: {
    force?: boolean;
    rateLimit?: number; // ms delay between requests
    onProgress?: (current: number, total: number) => void;
  } = {}
): Promise<string[]> {
  const { force = false, rateLimit = 1000, onProgress } = options;
  const results: string[] = [];

  for (let i = 0; i < artworks.length; i++) {
    const artwork = artworks[i];

    try {
      const filePath = await generateCommentary(artwork, force);
      results.push(filePath);

      if (onProgress) {
        onProgress(i + 1, artworks.length);
      }

      // Rate limiting
      if (i < artworks.length - 1 && rateLimit > 0) {
        console.log(`[WAIT] Rate limiting: ${rateLimit}ms`);
        await new Promise(resolve => setTimeout(resolve, rateLimit));
      }
    } catch (err) {
      console.error(`[ERROR] Failed to generate commentary for ${artwork.title}:`, err);
      // Continue with next artwork
    }
  }

  return results;
}

// ============================================================================
// Utilities
// ============================================================================

/**
 * Check if commentary exists for an artwork
 */
export async function hasCommentary(artwork: Artwork): Promise<boolean> {
  const content = await readCommentaryFile(artwork);
  return content !== null;
}

/**
 * Get commentary metadata from file
 */
export async function getCommentaryMetadata(artwork: Artwork): Promise<CommentaryMetadata | null> {
  const content = await readCommentaryFile(artwork);
  if (!content) return null;

  // Parse metadata footer
  const metadataMatch = content.match(/_Generated: (.+)_\s+_Model: (.+)_\s+_Prompt Version: (.+)_\s+_Human Edited: (.+)_/);

  if (!metadataMatch) return null;

  return {
    artworkId: artwork.id,
    generatedAt: metadataMatch[1],
    modelName: metadataMatch[2],
    promptVersion: metadataMatch[3],
    humanEdited: metadataMatch[4] === 'Yes',
    sources: [] // Would need to parse from content
  };
}
